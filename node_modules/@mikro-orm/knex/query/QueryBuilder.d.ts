/// <reference types="node" />
import { inspect } from 'util';
import type { Knex } from 'knex';
import { type AnyEntity, type ConnectionType, type Dictionary, type EntityData, type EntityMetadata, type EntityName, type EntityProperty, type FlushMode, type GroupOperator, LockMode, type LoggingOptions, type MetadataStorage, type ObjectQuery, PopulateHint, type PopulateOptions, type QBFilterQuery, type QBQueryOrderMap, QueryFlag, type QueryOrderMap, type QueryResult, type RequiredEntityData } from '@mikro-orm/core';
import { JoinType, QueryType } from './enums';
import type { AbstractSqlDriver } from '../AbstractSqlDriver';
import { type Alias, QueryBuilderHelper } from './QueryBuilderHelper';
import type { SqlEntityManager } from '../SqlEntityManager';
import type { Field, ICriteriaNodeProcessOptions, JoinOptions } from '../typings';
import type { AbstractSqlPlatform } from '../AbstractSqlPlatform';
export interface ExecuteOptions {
    mapResults?: boolean;
    mergeResults?: boolean;
}
/**
 * SQL query builder with fluent interface.
 *
 * ```ts
 * const qb = orm.em.createQueryBuilder(Publisher);
 * qb.select('*')
 *   .where({
 *     name: 'test 123',
 *     type: PublisherType.GLOBAL,
 *   })
 *   .orderBy({
 *     name: QueryOrder.DESC,
 *     type: QueryOrder.ASC,
 *   })
 *   .limit(2, 1);
 *
 * const publisher = await qb.getSingleResult();
 * ```
 */
export declare class QueryBuilder<T extends object = AnyEntity> {
    protected readonly metadata: MetadataStorage;
    protected readonly driver: AbstractSqlDriver;
    protected readonly context?: Knex.Transaction<any, any[]> | undefined;
    protected connectionType?: ConnectionType | undefined;
    protected em?: SqlEntityManager<AbstractSqlDriver<import("..").AbstractSqlConnection, AbstractSqlPlatform>> | undefined;
    protected loggerContext?: (LoggingOptions & Dictionary) | undefined;
    get mainAlias(): Alias<T>;
    get alias(): string;
    get helper(): QueryBuilderHelper;
    /** @internal */
    type?: QueryType;
    /** @internal */
    _fields?: Field<T>[];
    /** @internal */
    _populate: PopulateOptions<T>[];
    /** @internal */
    _populateWhere?: ObjectQuery<T> | PopulateHint | `${PopulateHint}`;
    /** @internal */
    __populateWhere?: ObjectQuery<T> | PopulateHint | `${PopulateHint}`;
    /** @internal */
    _populateMap: Dictionary<string>;
    /** @internal */
    readonly rawFragments: Set<string>;
    protected aliasCounter: number;
    protected flags: Set<QueryFlag>;
    protected finalized: boolean;
    protected _joins: Dictionary<JoinOptions>;
    protected _explicitAlias: boolean;
    protected _schema?: string;
    protected _cond: Dictionary;
    protected _data: Dictionary;
    protected _orderBy: QueryOrderMap<T>[];
    protected _groupBy: Field<T>[];
    protected _having: Dictionary;
    protected _returning?: Field<T>[];
    protected _onConflict?: {
        fields: string[];
        ignore?: boolean;
        merge?: EntityData<T> | Field<T>[];
        where?: QBFilterQuery<T>;
    }[];
    protected _limit?: number;
    protected _offset?: number;
    protected _distinctOn?: string[];
    protected _joinedProps: Map<string, PopulateOptions<any>>;
    protected _cache?: boolean | number | [string, number];
    protected _indexHint?: string;
    protected _comments: string[];
    protected _hintComments: string[];
    protected flushMode?: FlushMode;
    protected lockMode?: LockMode;
    protected lockTables?: string[];
    protected subQueries: Dictionary<string>;
    protected _mainAlias?: Alias<T>;
    protected _aliases: Dictionary<Alias<any>>;
    protected _helper?: QueryBuilderHelper;
    protected _query?: {
        sql?: string;
        _sql?: Knex.Sql;
        params?: readonly unknown[];
        qb: Knex.QueryBuilder<T>;
    };
    protected readonly platform: AbstractSqlPlatform;
    protected readonly knex: Knex;
    /**
     * @internal
     */
    constructor(entityName: EntityName<T> | QueryBuilder<T>, metadata: MetadataStorage, driver: AbstractSqlDriver, context?: Knex.Transaction<any, any[]> | undefined, alias?: string, connectionType?: ConnectionType | undefined, em?: SqlEntityManager<AbstractSqlDriver<import("..").AbstractSqlConnection, AbstractSqlPlatform>> | undefined, loggerContext?: (LoggingOptions & Dictionary) | undefined);
    select(fields: Field<T> | Field<T>[], distinct?: boolean): SelectQueryBuilder<T>;
    addSelect(fields: Field<T> | Field<T>[]): SelectQueryBuilder<T>;
    distinct(): SelectQueryBuilder<T>;
    /** postgres only */
    distinctOn(fields: string | string[]): SelectQueryBuilder<T>;
    insert(data: RequiredEntityData<T> | RequiredEntityData<T>[]): InsertQueryBuilder<T>;
    update(data: EntityData<T>): UpdateQueryBuilder<T>;
    delete(cond?: QBFilterQuery): DeleteQueryBuilder<T>;
    truncate(): TruncateQueryBuilder<T>;
    count(field?: string | string[], distinct?: boolean): CountQueryBuilder<T>;
    join(field: string | Knex.QueryBuilder | QueryBuilder<any>, alias: string, cond?: QBFilterQuery, type?: JoinType, path?: string, schema?: string): this;
    innerJoin(field: string | Knex.QueryBuilder | QueryBuilder<any>, alias: string, cond?: QBFilterQuery, schema?: string): this;
    innerJoinLateral(field: string | Knex.QueryBuilder | QueryBuilder<any>, alias: string, cond?: QBFilterQuery, schema?: string): this;
    leftJoin(field: string | Knex.QueryBuilder | QueryBuilder<any>, alias: string, cond?: QBFilterQuery, schema?: string): this;
    leftJoinLateral(field: string | Knex.QueryBuilder | QueryBuilder<any>, alias: string, cond?: QBFilterQuery, schema?: string): this;
    joinAndSelect(field: string | [field: string, qb: Knex.QueryBuilder | QueryBuilder<any>], alias: string, cond?: QBFilterQuery, type?: JoinType, path?: string, fields?: string[], schema?: string): SelectQueryBuilder<T>;
    leftJoinAndSelect(field: string | [field: string, qb: Knex.QueryBuilder | QueryBuilder<any>], alias: string, cond?: QBFilterQuery, fields?: string[], schema?: string): SelectQueryBuilder<T>;
    leftJoinLateralAndSelect(field: string | [field: string, qb: Knex.QueryBuilder | QueryBuilder<any>], alias: string, cond?: QBFilterQuery, fields?: string[], schema?: string): SelectQueryBuilder<T>;
    innerJoinAndSelect(field: string | [field: string, qb: Knex.QueryBuilder | QueryBuilder<any>], alias: string, cond?: QBFilterQuery, fields?: string[], schema?: string): SelectQueryBuilder<T>;
    innerJoinLateralAndSelect(field: string | [field: string, qb: Knex.QueryBuilder | QueryBuilder<any>], alias: string, cond?: QBFilterQuery, fields?: string[], schema?: string): SelectQueryBuilder<T>;
    protected getFieldsForJoinedLoad(prop: EntityProperty<T>, alias: string, explicitFields?: string[]): Field<T>[];
    withSubQuery(subQuery: Knex.QueryBuilder, alias: string): this;
    where(cond: QBFilterQuery<T>, operator?: keyof typeof GroupOperator): this;
    where(cond: string, params?: any[], operator?: keyof typeof GroupOperator): this;
    andWhere(cond: QBFilterQuery<T>): this;
    andWhere(cond: string, params?: any[]): this;
    orWhere(cond: QBFilterQuery<T>): this;
    orWhere(cond: string, params?: any[]): this;
    orderBy(orderBy: QBQueryOrderMap<T> | QBQueryOrderMap<T>[]): SelectQueryBuilder<T>;
    groupBy(fields: (string | keyof T) | readonly (string | keyof T)[]): SelectQueryBuilder<T>;
    having(cond?: QBFilterQuery | string, params?: any[]): SelectQueryBuilder<T>;
    onConflict(fields?: Field<T> | Field<T>[]): InsertQueryBuilder<T>;
    ignore(): this;
    merge(data?: EntityData<T> | Field<T>[]): this;
    returning(fields?: Field<T> | Field<T>[]): this;
    /**
     * @internal
     */
    populate(populate: PopulateOptions<T>[], populateWhere?: ObjectQuery<T> | PopulateHint | `${PopulateHint}`): this;
    limit(limit?: number, offset?: number): SelectQueryBuilder<T>;
    offset(offset?: number): SelectQueryBuilder<T>;
    withSchema(schema?: string): this;
    setLockMode(mode?: LockMode, tables?: string[]): this;
    setFlushMode(flushMode?: FlushMode): this;
    setFlag(flag: QueryFlag): this;
    unsetFlag(flag: QueryFlag): this;
    hasFlag(flag: QueryFlag): boolean;
    cache(config?: boolean | number | [string, number]): this;
    /**
     * Adds index hint to the FROM clause.
     */
    indexHint(sql: string): this;
    /**
     * Prepend comment to the sql query using the syntax `/* ... *&#8205;/`. Some characters are forbidden such as `/*, *&#8205;/` and `?`.
     */
    comment(comment: string | string[]): this;
    /**
     * Add hints to the query using comment-like syntax `/*+ ... *&#8205;/`. MySQL and Oracle use this syntax for optimizer hints.
     * Also various DB proxies and routers use this syntax to pass hints to alter their behavior. In other dialects the hints
     * are ignored as simple comments.
     */
    hintComment(comment: string | string[]): this;
    /**
     * Specifies FROM which entity's table select/update/delete will be executed, removing all previously set FROM-s.
     * Allows setting a main string alias of the selection data.
     */
    from<T extends AnyEntity<T> = AnyEntity>(target: QueryBuilder<T>, aliasName?: string): SelectQueryBuilder<T>;
    from<T extends AnyEntity<T> = AnyEntity>(target: EntityName<T>): SelectQueryBuilder<T>;
    getKnexQuery(processVirtualEntity?: boolean): Knex.QueryBuilder;
    /**
     * @internal
     */
    clearRawFragmentsCache(): void;
    /**
     * Returns the query with parameters as wildcards.
     */
    getQuery(): string;
    toQuery(): {
        sql: string;
        _sql: Knex.Sql;
        params: readonly unknown[];
    };
    /**
     * Returns the list of all parameters for this query.
     */
    getParams(): readonly Knex.Value[];
    /**
     * Returns raw interpolated query string with all the parameters inlined.
     */
    getFormattedQuery(): string;
    /**
     * @internal
     */
    getAliasForJoinPath(path?: string | JoinOptions, options?: ICriteriaNodeProcessOptions): string | undefined;
    /**
     * @internal
     */
    getJoinForPath(path: string, options?: ICriteriaNodeProcessOptions): JoinOptions | undefined;
    /**
     * @internal
     */
    getNextAlias(entityName?: string): string;
    /**
     * @internal
     */
    getAliasMap(): Dictionary<string>;
    /**
     * Executes this QB and returns the raw results, mapped to the property names (unless disabled via last parameter).
     * Use `method` to specify what kind of result you want to get (array/single/meta).
     */
    execute<U = any>(method?: 'all' | 'get' | 'run', options?: ExecuteOptions | boolean): Promise<U>;
    /**
     * Alias for `qb.getResultList()`
     */
    getResult(): Promise<T[]>;
    /**
     * Executes the query, returning array of results
     */
    getResultList(limit?: number): Promise<T[]>;
    /**
     * Executes the query, returning the first result or null
     */
    getSingleResult(): Promise<T | null>;
    /**
     * Executes count query (without offset and limit), returning total count of results
     */
    getCount(field?: string | string[], distinct?: boolean): Promise<number>;
    /**
     * Executes the query, returning both array of results and total count query (without offset and limit).
     */
    getResultAndCount(): Promise<[T[], number]>;
    /**
     * Provides promise-like interface so we can await the QB instance.
     */
    then<TResult1 = any, TResult2 = never>(onfulfilled?: ((value: any) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<T[] | number | QueryResult<T>>;
    /**
     * Returns knex instance with sub-query aliased with given alias.
     * You can provide `EntityName.propName` as alias, then the field name will be used based on the metadata
     */
    as(alias: string): Knex.QueryBuilder;
    clone(reset?: boolean | string[]): QueryBuilder<T>;
    getKnex(processVirtualEntity?: boolean): Knex.QueryBuilder;
    /**
     * Sets logger context for this query builder.
     */
    setLoggerContext(context: LoggingOptions & Dictionary): void;
    /**
     * Gets logger context for this query builder.
     */
    getLoggerContext<T extends Dictionary & LoggingOptions = Dictionary>(): T;
    private fromVirtual;
    private joinReference;
    protected prepareFields<T, U extends string | Knex.Raw>(fields: Field<T>[], type?: 'where' | 'groupBy' | 'sub-query'): U[];
    private init;
    private getQueryBase;
    private applyDiscriminatorCondition;
    private finalize;
    private processPopulateWhere;
    private hasToManyJoins;
    protected wrapPaginateSubQuery(meta: EntityMetadata): void;
    private wrapModifySubQuery;
    private getSchema;
    private createAlias;
    private createMainAlias;
    private fromSubQuery;
    private fromEntityName;
    private createQueryBuilderHelper;
    private ensureFromClause;
    private ensureNotFinalized;
    /** @ignore */
    [inspect.custom](depth?: number): string;
}
export interface RunQueryBuilder<T extends object> extends Omit<QueryBuilder<T>, 'getResult' | 'getSingleResult' | 'getResultList' | 'where'> {
    where(cond: QBFilterQuery<T> | string, params?: keyof typeof GroupOperator | any[], operator?: keyof typeof GroupOperator): this;
    execute<U = QueryResult<T>>(method?: 'all' | 'get' | 'run', mapResults?: boolean): Promise<U>;
    then<TResult1 = QueryResult<T>, TResult2 = never>(onfulfilled?: ((value: QueryResult<T>) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<QueryResult<T>>;
}
export interface SelectQueryBuilder<T extends object> extends QueryBuilder<T> {
    execute<U = T[]>(method?: 'all' | 'get' | 'run', mapResults?: boolean): Promise<U>;
    execute<U = T[]>(method: 'all', mapResults?: boolean): Promise<U>;
    execute<U = T>(method: 'get', mapResults?: boolean): Promise<U>;
    execute<U = QueryResult<T>>(method: 'run', mapResults?: boolean): Promise<U>;
    then<TResult1 = T[], TResult2 = never>(onfulfilled?: ((value: T[]) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<T[]>;
}
export interface CountQueryBuilder<T extends object> extends QueryBuilder<T> {
    execute<U = {
        count: number;
    }[]>(method?: 'all' | 'get' | 'run', mapResults?: boolean): Promise<U>;
    execute<U = {
        count: number;
    }[]>(method: 'all', mapResults?: boolean): Promise<U>;
    execute<U = {
        count: number;
    }>(method: 'get', mapResults?: boolean): Promise<U>;
    execute<U = QueryResult<{
        count: number;
    }>>(method: 'run', mapResults?: boolean): Promise<U>;
    then<TResult1 = number, TResult2 = never>(onfulfilled?: ((value: number) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<number>;
}
export interface InsertQueryBuilder<T extends object> extends RunQueryBuilder<T> {
}
export interface UpdateQueryBuilder<T extends object> extends RunQueryBuilder<T> {
}
export interface DeleteQueryBuilder<T extends object> extends RunQueryBuilder<T> {
}
export interface TruncateQueryBuilder<T extends object> extends RunQueryBuilder<T> {
}
