"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaHelper = void 0;
const core_1 = require("@mikro-orm/core");
class SchemaHelper {
    platform;
    constructor(platform) {
        this.platform = platform;
    }
    getSchemaBeginning(charset) {
        return `${this.disableForeignKeysSQL()}\n\n`;
    }
    disableForeignKeysSQL() {
        return '';
    }
    enableForeignKeysSQL() {
        return '';
    }
    getSchemaEnd() {
        return `${this.enableForeignKeysSQL()}\n`;
    }
    finalizeTable(table, charset, collate) {
        //
    }
    supportsSchemaConstraints() {
        return true;
    }
    async getPrimaryKeys(connection, indexes = [], tableName, schemaName) {
        const pks = indexes.filter(i => i.primary).map(pk => pk.columnNames);
        return core_1.Utils.flatten(pks);
    }
    inferLengthFromColumnType(type) {
        return undefined;
    }
    async getForeignKeys(connection, tableName, schemaName) {
        const fks = await connection.execute(this.getForeignKeysSQL(tableName, schemaName));
        return this.mapForeignKeys(fks, tableName, schemaName);
    }
    getTableKey(t) {
        const unquote = (str) => str.replace(/['"`]/g, '');
        const parts = t.table_name.split('.');
        if (parts.length > 1) {
            return `${unquote(parts[0])}.${unquote(parts[1])}`;
        }
        if (t.schema_name) {
            return `${unquote(t.schema_name)}.${unquote(t.table_name)}`;
        }
        return unquote(t.table_name);
    }
    async getEnumDefinitions(connection, checks, tableName, schemaName) {
        return {};
    }
    getCreateNativeEnumSQL(name, values, schema) {
        throw new Error('Not supported by given driver');
    }
    getDropNativeEnumSQL(name, schema) {
        throw new Error('Not supported by given driver');
    }
    getAlterNativeEnumSQL(name, schema, value) {
        throw new Error('Not supported by given driver');
    }
    async loadInformationSchema(schema, connection, tables, schemas) {
        for (const t of tables) {
            const table = schema.addTable(t.table_name, t.schema_name);
            table.comment = t.table_comment;
            const cols = await this.getColumns(connection, table.name, table.schema);
            const indexes = await this.getIndexes(connection, table.name, table.schema);
            const checks = await this.getChecks(connection, table.name, table.schema, cols);
            const pks = await this.getPrimaryKeys(connection, indexes, table.name, table.schema);
            const fks = await this.getForeignKeys(connection, table.name, table.schema);
            const enums = await this.getEnumDefinitions(connection, checks, table.name, table.schema);
            table.init(cols, indexes, checks, pks, fks, enums);
        }
    }
    getListTablesSQL(schemaName) {
        throw new Error('Not supported by given driver');
    }
    getRenameColumnSQL(tableName, oldColumnName, to, schemaName) {
        tableName = this.platform.quoteIdentifier(tableName);
        oldColumnName = this.platform.quoteIdentifier(oldColumnName);
        const columnName = this.platform.quoteIdentifier(to.name);
        const schemaReference = (schemaName !== undefined && schemaName !== 'public') ? ('"' + schemaName + '".') : '';
        const tableReference = schemaReference + tableName;
        return `alter table ${tableReference} rename column ${oldColumnName} to ${columnName}`;
    }
    getCreateIndexSQL(tableName, index, partialExpression = false) {
        /* istanbul ignore next */
        if (index.expression && !partialExpression) {
            return index.expression;
        }
        tableName = this.platform.quoteIdentifier(tableName);
        const keyName = this.platform.quoteIdentifier(index.keyName);
        const sql = `create ${index.unique ? 'unique ' : ''}index ${keyName} on ${tableName} `;
        if (index.expression && partialExpression) {
            return `${sql}(${index.expression})`;
        }
        return `${sql}(${index.columnNames.map(c => this.platform.quoteIdentifier(c)).join(', ')})`;
    }
    getDropIndexSQL(tableName, index) {
        return `drop index ${this.platform.quoteIdentifier(index.keyName)}`;
    }
    getRenameIndexSQL(tableName, index, oldIndexName) {
        return [this.getDropIndexSQL(tableName, { ...index, keyName: oldIndexName }), this.getCreateIndexSQL(tableName, index)].join(';\n');
    }
    getDropColumnsSQL(tableName, columns, schemaName) {
        const name = this.platform.quoteIdentifier((schemaName && schemaName !== this.platform.getDefaultSchemaName() ? schemaName + '.' : '') + tableName);
        const drops = columns.map(column => `drop column ${this.platform.quoteIdentifier(column.name)}`).join(', ');
        return `alter table ${name} ${drops}`;
    }
    hasNonDefaultPrimaryKeyName(table) {
        const pkIndex = table.getPrimaryKey();
        if (!pkIndex || !this.platform.supportsCustomPrimaryKeyNames()) {
            return false;
        }
        const defaultName = this.platform.getDefaultPrimaryName(table.name, pkIndex.columnNames);
        return pkIndex?.keyName !== defaultName;
    }
    createTableColumn(table, column, fromTable, changedProperties, alter) {
        const compositePK = fromTable.getPrimaryKey()?.composite;
        if (column.autoincrement && !column.generated && !compositePK && (!changedProperties || changedProperties.has('autoincrement') || changedProperties.has('type'))) {
            const primaryKey = !changedProperties && !this.hasNonDefaultPrimaryKeyName(fromTable);
            if (column.mappedType instanceof core_1.BigIntType) {
                return table.bigIncrements(column.name, { primaryKey });
            }
            return table.increments(column.name, { primaryKey });
        }
        if (column.mappedType instanceof core_1.EnumType && column.enumItems?.every(item => core_1.Utils.isString(item))) {
            return table.enum(column.name, column.enumItems);
        }
        let columnType = column.type;
        if (column.generated) {
            columnType += ` generated always as ${column.generated}`;
        }
        return table.specificType(column.name, columnType);
    }
    configureColumn(column, col, knex, changedProperties) {
        const guard = (key) => !changedProperties || changedProperties.has(key);
        core_1.Utils.runIfNotEmpty(() => col.nullable(), column.nullable && guard('nullable'));
        core_1.Utils.runIfNotEmpty(() => col.notNullable(), !column.nullable && !column.generated);
        core_1.Utils.runIfNotEmpty(() => col.unsigned(), column.unsigned);
        core_1.Utils.runIfNotEmpty(() => col.comment(column.comment), column.comment);
        this.configureColumnDefault(column, col, knex, changedProperties);
        return col;
    }
    configureColumnDefault(column, col, knex, changedProperties) {
        const guard = (key) => !changedProperties || changedProperties.has(key);
        if (changedProperties) {
            core_1.Utils.runIfNotEmpty(() => col.defaultTo(column.default == null ? null : knex.raw(column.default)), guard('default'));
        }
        else {
            core_1.Utils.runIfNotEmpty(() => col.defaultTo(knex.raw(column.default)), column.default != null && column.default !== 'null');
        }
        return col;
    }
    getPreAlterTable(tableDiff, safe) {
        return '';
    }
    getPostAlterTable(tableDiff, safe) {
        return '';
    }
    getAlterColumnAutoincrement(tableName, column, schemaName) {
        return '';
    }
    getChangeColumnCommentSQL(tableName, to, schemaName) {
        return '';
    }
    async getNamespaces(connection) {
        return [];
    }
    async getColumns(connection, tableName, schemaName) {
        throw new Error('Not supported by given driver');
    }
    async getIndexes(connection, tableName, schemaName) {
        throw new Error('Not supported by given driver');
    }
    async getChecks(connection, tableName, schemaName, columns) {
        throw new Error('Not supported by given driver');
    }
    async mapIndexes(indexes) {
        const map = {};
        indexes.forEach(index => {
            if (map[index.keyName]) {
                map[index.keyName].composite = true;
                map[index.keyName].columnNames.push(index.columnNames[0]);
            }
            else {
                map[index.keyName] = index;
            }
        });
        return Object.values(map);
    }
    getForeignKeysSQL(tableName, schemaName) {
        throw new Error('Not supported by given driver');
    }
    mapForeignKeys(fks, tableName, schemaName) {
        return fks.reduce((ret, fk) => {
            if (ret[fk.constraint_name]) {
                ret[fk.constraint_name].columnNames.push(fk.column_name);
                ret[fk.constraint_name].referencedColumnNames.push(fk.referenced_column_name);
            }
            else {
                ret[fk.constraint_name] = {
                    columnNames: [fk.column_name],
                    constraintName: fk.constraint_name,
                    localTableName: schemaName ? `${schemaName}.${tableName}` : tableName,
                    referencedTableName: fk.referenced_schema_name ? `${fk.referenced_schema_name}.${fk.referenced_table_name}` : fk.referenced_table_name,
                    referencedColumnNames: [fk.referenced_column_name],
                    updateRule: fk.update_rule.toLowerCase(),
                    deleteRule: fk.delete_rule.toLowerCase(),
                    deferMode: fk.defer_mode,
                };
            }
            return ret;
        }, {});
    }
    normalizeDefaultValue(defaultValue, length, defaultValues = {}) {
        if (defaultValue == null) {
            return defaultValue;
        }
        const raw = core_1.RawQueryFragment.getKnownFragment(defaultValue);
        if (raw) {
            return this.platform.formatQuery(raw.sql, raw.params);
        }
        const genericValue = defaultValue.replace(/\(\d+\)/, '(?)').toLowerCase();
        const norm = defaultValues[genericValue];
        if (!norm) {
            return defaultValue;
        }
        return norm[0].replace('(?)', length != null ? `(${length})` : '');
    }
    getCreateDatabaseSQL(name) {
        // two line breaks to force separate execution
        return `create database ${name};\n\nuse ${name}`;
    }
    getDropDatabaseSQL(name) {
        return `drop database if exists ${this.platform.quoteIdentifier(name)}`;
    }
    /* istanbul ignore next */
    getCreateNamespaceSQL(name) {
        return `create schema if not exists ${this.platform.quoteIdentifier(name)}`;
    }
    /* istanbul ignore next */
    getDropNamespaceSQL(name) {
        return `drop schema if exists ${this.platform.quoteIdentifier(name)}`;
    }
    getDatabaseExistsSQL(name) {
        return `select 1 from information_schema.schemata where schema_name = '${name}'`;
    }
    getDatabaseNotExistsError(dbName) {
        return `Unknown database '${dbName}'`;
    }
    getManagementDbName() {
        return 'information_schema';
    }
    getDefaultEmptyString() {
        return "''";
    }
    async databaseExists(connection, name) {
        try {
            const res = await connection.execute(this.getDatabaseExistsSQL(name));
            return res.length > 0;
        }
        catch (e) {
            if (e instanceof Error && e.message.includes(this.getDatabaseNotExistsError(name))) {
                return false;
            }
            throw e;
        }
    }
    /**
     * Uses `raw` method injected in `AbstractSqlConnection` to allow adding custom queries inside alter statements.
     */
    pushTableQuery(table, expression, grouping = 'alterTable') {
        table._statements.push({ grouping, method: 'raw', args: [expression] });
    }
}
exports.SchemaHelper = SchemaHelper;
